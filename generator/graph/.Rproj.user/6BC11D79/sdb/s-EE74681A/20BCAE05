{
    "collab_server" : "",
    "contents" : "\n\n##========================================================##\n##                                                        ##\n##   Network Visualization with R                         ##\n##   Polnet 2017 Workshop, Columbus, OH                   ##\n##   www.kateto.net/polnet2017                            ##\n##                                                        ##\n##   Katherine (Katya) Ognyanova                          ##\n##   Web: kateto.net | Email: katya@ognyanova.net         ##\n##   GitHub: kateto  | Twitter: @Ognyanova                ##\n##                                                        ##\n##========================================================##\n\n\n\n# ================ Introduction ================ \n\n\n# Download handouts and example data: bit.ly/polnet2017\n# Online tutorial: kateto.net/polnet2017\n\n\n# CONTENTS\n#\n#   1. R colors and fonts\n#   2. Reading in the network data\n#   3. Plotting networks with 'igraph' \n#   4. Plotting two-mode networks\n#   5. Plotting multiplex networks\n#   6. Quick example using 'network' \n#   7. Simple plot animations in R\n#   8. Interactive JavaScript networks \n#   9. Interactive and dynamic networks with ndtv-d3\n#  10. Plotting networks on a geographic map\n#\n\n\n# KEY PACKAGES\n# Install those now if you do not have the latest versions. \n# (please do NOT load them yet!)\n\ninstall.packages(\"igraph\") \ninstall.packages(\"network\") \ninstall.packages(\"sna\")\ninstall.packages(\"visNetwork\")\ninstall.packages(\"threejs\")\ninstall.packages(\"ndtv\")\n\n\n# OPTIONAL PACKAGES\n# Install those if you  would like to run through all of the\n# examples below (those are not critical and can be skipped).\n\ninstall.packages(\"RColorBrewer\")\ninstall.packages(\"extrafont\")\ninstall.packages(\"png\")\ninstall.packages(\"networkD3\")\ninstall.packages(\"animation\")\ninstall.packages(\"maps\")\ninstall.packages(\"geosphere\")\n \n\n\n\n# ================ 1. R colors and fonts ================ \n \n\n\n#  ------->> Colors in R plots --------\n\n\n# --COLORS--\n\n# In most R functions, you can use named colors, hex, or rgb values:\n\nplot(x=1:10, y=rep(5,10), pch=19, cex=5, col=\"dark red\")\npoints(x=1:10, y=rep(6, 10), pch=19, cex=5, col=\"#557799\")\npoints(x=1:10, y=rep(4, 10), pch=19, cex=5, col=rgb(.25, .5, .3))\n\n# In the simple base plot chart above, x and y are point coordinates, 'pch' \n# is the point symbol shape, 'cex' is the point size, and 'col' is the color.\n# to see the parameters for plotting in base R, check out ?par\n\n# If you plan on using the built-in color names, here's what they are: \ncolors() # all colors\ngrep(\"blue\", colors(), value=T) # colors that have 'blue' in the name\n\n# You may notice that rgb here ranges from 0 to 1. While this is the R default,\n# you can also set it for the more typical 0-255 range: \nrgb(10, 100, 100, maxColorValue=255) \n\n\n# --TRANSPARENCY--\n\n# We can also set the opacity/transparency using the parameter 'alpha' (range 0-1):\nplot(x=1:5, y=rep(5,5), pch=19, cex=16, col=rgb(.25, .5, .3, alpha=.5), xlim=c(0,6))  \n\n# If we have a hex color representation, we can set the transparency alpha \n# using 'adjustcolor' from package 'grDevices'. For fun, let's also set the\n# the plot background to black using the par() function for graphical parameters.\n# We could also set the margins in par() with mar=c(bottom, left, top, right).\npar(bg=\"black\")\n\ncol.tr <- grDevices::adjustcolor(\"#557799\", alpha=0.7)\nplot(x=1:5, y=rep(5,5), pch=19, cex=20, col=col.tr, xlim=c(0,6)) \n\npar(bg=\"white\")\n\n\n# --PALETTES--\n\n# In many cases, we need a number of contrasting colors, or multiple shades of a color.\n# R comes with some predefined palette function that can generate those for us.\npal1 <- heat.colors(5, alpha=1)   # generate 5 colors from the heat palette, opaque\npal2 <- rainbow(5, alpha=.5)      # generate 5 colors from the heat palette, semi-transparent\nplot(x=1:10, y=1:10, pch=19, cex=10, col=pal1)\npar(new=TRUE) # tells R not to clear the first plot before adding the second one\nplot(x=10:1, y=1:10, pch=19, cex=10, col=pal2)\n\n# We can also generate our own gradients using colorRampPalette().\n# Note that colorRampPalette returns a *function* that we can use \n# to generate as many colors from that palette as we need.\n\npalf <- colorRampPalette(c(\"gray70\", \"dark red\")) \nplot(x=10:1, y=1:10, pch=19, cex=10, col=palf(10)) \n\n# To add transparency to colorRampPalette, you need to add a parameter `alpha=TRUE`:\npalf <- colorRampPalette(c(rgb(1,1,1, .2),rgb(.8,0,0, .7)), alpha=TRUE)\nplot(x=10:1, y=1:10, pch=19, cex=10, col=palf(10)) \n\n\n# --COLORBREWER--\n\n# Finding good color combinations is a tough task - and the built-in R palettes\n# are rather limited. Thankfully there are other available packages for this:\n\n# install.packages(\"RColorBrewer\")\nlibrary(\"RColorBrewer\")\n\ndisplay.brewer.all()\n\n# This package has one main function, called 'brewer.pal'.\n# Using it, you just need to select the desired palette and a number of colors.\n# Let's take a look at some of the RColorBrewer palettes:\ndisplay.brewer.pal(8, \"Set3\")\ndisplay.brewer.pal(8, \"Spectral\")\ndisplay.brewer.pal(8, \"Blues\")\n\n\n# Plot figures using ColorBrewer\n# We'll use par() to plot multiple figures.\n# plot row by row: mfrow=c(number of rows, number of columns)\n# plot column by column: mfcol=c(number of rows, number of columns)\n\npar(mfrow=c(1,2)) # plot two figures - 1 row, 2 columns\n\npal3 <- brewer.pal(10, \"Set3\")\nplot(x=10:1, y=10:1, pch=19, cex=6, col=pal3)\nplot(x=10:1, y=10:1, pch=19, cex=6, col=rev(pal3)) # backwards\n\ndev.off() # shut off the  graphic device to clear the two-figure configuration.\n\n\ndetach(\"package:RColorBrewer\")\n\n\n\n\n#  ------->> Fonts in R plots --------\n\n# Using different fonts for R plots may take a little bit of work.\n# Especially for Windows - Mac & Linux users may not have to do this.\n# First we'd use the 'extrafont' package to import the fonts from the OS into R:\n\n# install.packages(\"extrafont\")\n\nlibrary(\"extrafont\")\n\n# Import system fonts - may take a while, so DO NOT run this during the workshop.\n# font_import() \nfonts() # See what font families are available to you now.\nloadfonts(device = \"win\") # use device = \"pdf\" for pdf plot output. \n \n# Now you should be able to do  this:\nplot(x=10:1, y=10:1, pch=19, cex=6, main=\"This is a plot\", \n     col=\"orange\", family=\"Arial Black\" )\n\n# To embed the fonts & use them in PDF files:\n# First you may have to let R know where to find ghostscript\nSys.setenv(R_GSCMD = \"C:/Program Files/gs/gs9.21/bin/gswin64c.exe\")\n\nloadfonts(device = \"pdf\")\n\n# The function 'pdf' will send all the plots we output before dev.off() to a pdf file: \npdf(file=\"ArialBlack.pdf\")\nplot(x=10:1, y=10:1, pch=19, cex=6, main=\"This is a plot\", \n     col=\"orange\", family=\"Arial Black\" )\ndev.off()\n\nembed_fonts(\"ArialBlack.pdf\", outfile=\"ArialBlack_embed.pdf\")\n\n\ndetach(\"package:extrafont\")\n\n \n\n# ================ 2. Reading in the network data ================\n\n\n# Download an archive with the data files from http://bit.ly/polnet2017  \n\n# Clear your workspace by removing all objects returned by ls():\nrm(list = ls()) \n \n# Set the working directory to the folder containing the workshop files:\nsetwd(\"C:/polnet2017\") \n\n# If you don't know the path to the folder and you're in RStudio, go to the\n# \"Session\" menu -> \"Set Working Directory\" -> \"To Source File Location\"\n\n\n# --DATASET 1: edgelist--\n\nnodes <- read.csv(\"./Data files/Dataset1-Media-Example-NODES.csv\", header=T, as.is=T)\nlinks <- read.csv(\"./Data files/Dataset1-Media-Example-EDGES.csv\", header=T, as.is=T)\n\n# Examine the data:\nhead(nodes)\nhead(links)\n\nnrow(nodes); length(unique(nodes$id))\nnrow(links); nrow(unique(links[,c(\"from\", \"to\")]))\nnrow(unique(links[,c(\"from\", \"to\", \"type\")]))\n\n# Collapse multiple links of the same type between the same two nodes\n# by summing their weights, using aggregate() by \"from\", \"to\", & \"type\":\nlinks <- aggregate(links[,3], links[,-3], sum)\nlinks <- links[order(links$from, links$to),]\ncolnames(links)[4] <- \"weight\"\nrownames(links) <- NULL\n\nnrow(links); nrow(unique(links[,c(\"from\", \"to\")]))\n\n\n\n# --DATASET 2: matrix--\n\nnodes2 <- read.csv(\"./Data files/Dataset2-Media-User-Example-NODES.csv\", header=T, as.is=T)\nlinks2 <- read.csv(\"./Data files/Dataset2-Media-User-Example-EDGES.csv\", header=T, row.names=1)\n\n# Examine the data:\nhead(nodes2)\nhead(links2)\n\n# links2 is a matrix for a two-mode network:\nlinks2 <- as.matrix(links2)\ndim(links2)\ndim(nodes2)\n\n\n# ================ 3. Plotting networks with igraph ================\n\n  \n#  ------->> Turning networks into igraph objects  --------\n\nlibrary(\"igraph\")\n\n# DATASET 1 \n\n# Converting the data to an igraph object:\n# The graph_from_data_frame() function takes two data frames: 'd' and 'vertices'.\n# 'd' describes the edges of the network - it should start with two columns \n# containing the source and target node IDs for each network tie.\n# 'vertices' should start with a column of node IDs.\n# Any additional columns in either data frame are interpreted as attributes.\n\nnet <- graph_from_data_frame(d=links, vertices=nodes, directed=T) \n\n# Examine the resulting object:\nclass(net)\nnet \n\n# We can access the nodes, edges, and their attributes:\nE(net)\nV(net)\nE(net)$type\nV(net)$media\n\n# Or find specific nodes and edges by attribute:\n# (that returns objects of type vertex sequence / edge sequence)\nV(net)[media==\"BBC\"]\nE(net)[type==\"mention\"]\n\n\n# If you need them, you can extract an edge list \n# or a matrix back from the igraph networks.\nas_edgelist(net, names=T)\nas_adjacency_matrix(net, attr=\"weight\")\n\n# Or data frames describing nodes and edges:\nas_data_frame(net, what=\"edges\")\nas_data_frame(net, what=\"vertices\")\n\n\n# You can also look at the network matrix directly:\nnet[1,]\nnet[5,7]\n\n# First attempt to plot the graph:\nplot(net) # not pretty!\n\n# Removing loops from the graph:\nnet <- simplify(net, remove.multiple = F, remove.loops = T) \n\n# Let's and reduce the arrow size and remove the labels:\nplot(net, edge.arrow.size=.4,vertex.label=NA)\n \n\n\n# DATASET 2 \n\n\nhead(nodes2)\nhead(links2)\n\n# Create an igraph network object from the two-mode matrix: \nnet2 <- graph_from_incidence_matrix(links2)\n\n# A built-in vertex attribute 'type' shows which mode vertices belong to.\ntable(V(net2)$type)\n\nplot(net2,vertex.label=NA)\n\n# Examine the resulting object:\nclass(net2)\nnet2 \n\n# To transform a one-mode network matrix into an igraph object,\n# we would use graph_from_adjacency_matrix()\n \n\n \n#  ------->> Plotting parameters in igraph --------\n\n# Plotting with igraph: node options (starting with 'vertex.') and edge options\n# (starting with 'edge.'). A list of options is included in your handout.\n?igraph.plotting\n\n# We can set the node & edge options in two ways - one is to specify\n# them in the plot() function, as we are doing below.\n\n# Plot with curved edges (edge.curved=.1) and reduce arrow size:\n# Note that using curved edges will allow you to see multiple links\n# between two nodes (e.g. links going in either direction, or multiplex links)\nplot(net, edge.arrow.size=.4, edge.curved=.1)\n\n# Set node color to orange and the border color to hex #555555\n# Replace the vertex label with the node names stored in \"media\"\nplot(net, edge.arrow.size=.4, edge.curved=0,\n     vertex.color=\"orange\", vertex.frame.color=\"#555555\",\n     vertex.label=V(net)$media, vertex.label.color=\"black\",\n     vertex.label.cex=.7) \n\n\n# The second way to set attributes is to add them to the igraph object.\n\n# Generate colors based on media type:\ncolrs <- c(\"gray50\", \"tomato\", \"gold\")\nV(net)$color <- colrs[V(net)$media.type]\n\n# Compute node degree (#links) and use it to set node size:\ndeg <- degree(net, mode=\"all\")\nV(net)$size <- deg*3\nV(net)$size <- V(net)$audience.size*0.6\n\n# The labels are currently node IDs.\n# Setting them to NA will render no labels:\nV(net)$label.color <- \"black\"\nV(net)$label <- NA\n\n# Set edge width based on weight:\nE(net)$width <- E(net)$weight/6\n\n#change arrow size and edge color:\nE(net)$arrow.size <- .2\nE(net)$edge.color <- \"gray80\"\n\nplot(net) \n\n# We can also override the attributes explicitly in the plot:\nplot(net, edge.color=\"orange\", vertex.color=\"gray50\") \n\n\n# We can also add a legend explaining the meaning of the colors we used:\n# (below 'x' and 'y' are the legend coordinates, 'pch' is the element symbol, \n# 'pt.bg' is the point's background color, 'col' is the border color, \n# 'pt.cex' is the symbol size, 'bty' is the type of box around the legend,\n# and 'ncol' is the number of columns in which the legend is set).\n\nplot(net) \nlegend(x=-1.1, y=-1.1, c(\"Newspaper\",\"Television\", \"Online News\"), pch=21,\n       col=\"#777777\", pt.bg=colrs, pt.cex=2.5, bty=\"n\", ncol=3)\n\n\n# Sometimes, especially with semantic networks, we may be interested in \n# plotting only the labels of the nodes:\n\nplot(net, vertex.shape=\"none\", vertex.label=V(net)$media, \n     vertex.label.font=2, vertex.label.color=\"gray40\",\n     vertex.label.cex=1.2, edge.color=\"gray90\")\n\n\n# Let's color the edges of the graph based on their source node color.\n# Here 'ends()' gives us the start & end for each edge in 'es', and \n# 'names' controls whether 'ends()' will return node names or IDs.\n\nedge.start <- ends(net, es=E(net), names=F)[,1] # get the \"from\" node\nedge.col <- V(net)$color[edge.start]\n\nplot(net, edge.color=edge.col, edge.curved=.1)\n\n\n\n#  ------->> Network Layouts in igraph --------\n\n\n# Network layouts are algorithms that return coordinates for each\n# node in a network.\n\n# Let's generate a slightly larger 80-node graph using \n# a preferential attachment model (Barabasi-Albert).\n\nnet.bg <- sample_pa(80, 1.2) \nV(net.bg)$size <- 8\nV(net.bg)$frame.color <- \"white\"\nV(net.bg)$color <- \"orange\"\nV(net.bg)$label <- \"\" \nE(net.bg)$arrow.mode <- 0\nplot(net.bg)\n\n# Now let's plot this network using the layouts available in igraph.\n\n# You can set the layout in the plot function:\nplot(net.bg, layout=layout_randomly)\n\n# Or calculate the vertex coordinates in advance:\nl <- layout_in_circle(net.bg)\nplot(net.bg, layout=l)\n\n# l is simply a matrix of x,y coordinates (N x 2) for the N nodes in the graph. \n# You can generate your own:\nl\nl <- cbind(1:vcount(net.bg), c(1, vcount(net.bg):2))\nplot(net.bg, layout=l)\n\n# This layout is just an example and not very helpful - thankfully\n# 'igraph' has a number of built-in layouts, including:\n\n# Randomly placed vertices\nl <- layout_randomly(net.bg)\nplot(net.bg, layout=l)\n\n# Circle layout\nl <- layout_in_circle(net.bg)\nplot(net.bg, layout=l)\n\n# 3D sphere layout\nl <- layout_on_sphere(net.bg)\nplot(net.bg, layout=l)\n\n# The Fruchterman-Reingold force-directed algorithm \n# Nice but slow, most often used in graphs smaller than ~1000 vertices. \nl <- layout_with_fr(net.bg)\nplot(net.bg, layout=l)\n\n# You will also notice that the F-R layout is not deterministic - different \n# runs will result in slightly different configurations. Saving the layout \n# in l allows us to get the exact same result multiple times.\npar(mfrow=c(2,2), mar=c(1,1,1,1))\nplot(net.bg, layout=layout_with_fr)\nplot(net.bg, layout=layout_with_fr)\nplot(net.bg, layout=l)\nplot(net.bg, layout=l)\n\ndev.off()\n\n# By default, the coordinates of the plots are rescaled to the [-1,1] interval\n# for both x and y. You can change that with the parameter \"rescale=FALSE\"\n# and rescale your plot manually by multiplying the coordinates by a scalar.\n# You can use norm_coords to normalize the plot with the boundaries you want.\n# This way you can create more compact or spread out layout versions.\n\n# Get the layout coordinates:\nl <- layout_with_fr(net.bg)\n# Normalize them so that they are in the -1, 1 interval:\nl <- norm_coords(l, ymin=-1, ymax=1, xmin=-1, xmax=1)\n\npar(mfrow=c(2,2), mar=c(0,0,0,0))\nplot(net.bg, rescale=F, layout=l*0.4)\nplot(net.bg, rescale=F, layout=l*0.8)\nplot(net.bg, rescale=F, layout=l*1.2)\nplot(net.bg, rescale=F, layout=l*1.6)\n\ndev.off()\n\n# Another popular force-directed algorithm that produces nice results for\n# connected graphs is Kamada Kawai. Like Fruchterman Reingold, it attempts to \n# minimize the energy in a spring system.\n\nl <- layout_with_kk(net.bg)\nplot(net.bg, layout=l)\n\n#The MDS (multidimensional scaling) algorithm tries to place nodes based on some\n# measure of similarity or distance between them. More similar nodes are plotted \n# closer to each other. By default, the measure used is based on the shortest \n#paths between nodes in the network. That can be changed with the 'dist' parameter.\nplot(net.bg, layout=layout_with_mds)\n\n# The LGL algorithm is for large connected graphs. Here you can specify a root - \n# the node that will be placed in the middle of the layout.\nplot(net.bg, layout=layout_with_lgl)\n\n\n# By default, igraph uses a layout called 'layout_nicely' which selects\n# an appropriate layout algorithm based on the properties of the graph. \n\n# Check out all available layouts in igraph:\n?igraph::layout_\n\nlayouts <- grep(\"^layout_\", ls(\"package:igraph\"), value=TRUE)[-1] \n# Remove layouts that do not apply to our graph.\nlayouts <- layouts[!grepl(\"bipartite|merge|norm|sugiyama|tree\", layouts)]\n\npar(mfrow=c(3,3), mar=c(1,1,1,1))\n\nfor (layout in layouts) {\n  print(layout)\n  l <- do.call(layout, list(net)) \n  plot(net, edge.arrow.mode=0, layout=l, main=layout) }\n\ndev.off()\n\n\n\n# ------->> Highlighting aspects of the network --------\n\n\nplot(net)\n\n# Notice that our network plot is still not too helpful.\n# We can identify the type and size of nodes, but cannot see\n# much about the structure since the links we're examining are so dense.\n# One way to approach this is to see if we can sparsify the network.\n\nhist(links$weight)\nmean(links$weight)\nsd(links$weight)\n\n# There are more sophisticated ways to extract the key edges,\n# but for the purposes of this exercise we'll only keep ones\n# that have weight higher than the mean for the network.\n\n# We can delete edges using delete_edges(net, edges)\n# (or, by the way, add edges with add_edges(net, edges) )\ncut.off <- mean(links$weight) \nnet.sp <- delete_edges(net, E(net)[weight<cut.off])\nplot(net.sp) \n\n\n# Another way to think about this is to plot the two tie types \n# (hyperlinks and mentions) separately. We will do that in \n# section 5 of this tutorial: Plotting multiplex networks.\n\n\n# We can also try to make the network map more useful by\n# showing the communities within it.\n\n# Community detection based on label propagation:\nclp <- cluster_label_prop(net)\nclass(clp)\nclp$membership\n\n# Community detection returns an object of class \"communities\" \n# which igraph knows how to plot: \nplot(clp, net)\n \n# We can also plot the communities without relying on their built-in plot:\nV(net)$community <- clp$membership\ncolrs <- adjustcolor( c(\"gray50\", \"tomato\", \"gold\", \"yellowgreen\"), alpha=.6)\nplot(net, vertex.color=colrs[V(net)$community])\n\n\n\n# ------->> Highlighting specific nodes or links --------\n\n\n# Sometimes we want to focus the visualization on a particular node\n# or a group of nodes. Let's represent distance from the NYT:\ndist.from.NYT <- distances(net, v=V(net)[media==\"NY Times\"], to=V(net), weights=NA)\n\n# Set colors to plot the distances:\noranges <- colorRampPalette(c(\"dark red\", \"gold\"))\ncol <- oranges(max(dist.from.NYT)+1)\ncol <- col[dist.from.NYT+1]\n\nplot(net, vertex.color=col, vertex.label=dist.from.NYT, edge.arrow.size=.6, \n     vertex.label.color=\"white\")\n\n\n# We can also highlight paths between the nodes in the network.\n# Say here between MSNBC and the New York Post:\nnews.path <- shortest_paths(net, \n                            from = V(net)[media==\"MSNBC\"], \n                            to  = V(net)[media==\"New York Post\"],\n                            output = \"both\") # both path nodes and edges\n\n# Generate edge color variable to plot the path:\necol <- rep(\"gray80\", ecount(net))\necol[unlist(news.path$epath)] <- \"orange\"\n# Generate edge width variable to plot the path:\new <- rep(2, ecount(net))\new[unlist(news.path$epath)] <- 4\n# Generate node color variable to plot the path:\nvcol <- rep(\"gray40\", vcount(net))\nvcol[unlist(news.path$vpath)] <- \"gold\"\n\nplot(net, vertex.color=vcol, edge.color=ecol, \n     edge.width=ew, edge.arrow.mode=0)\n\n\n# Highlight the edges going into or out of a vertex, for instance the WSJ.\n# For a single node, use 'incident()', for multiple nodes use 'incident_edges()'\ninc.edges <- incident(net, V(net)[media==\"Wall Street Journal\"], mode=\"all\")\n\n# Set colors to plot the selected edges.\necol <- rep(\"gray80\", ecount(net))\necol[inc.edges] <- \"orange\"\nvcol <- rep(\"grey40\", vcount(net))\nvcol[V(net)$media==\"Wall Street Journal\"] <- \"gold\"\nplot(net, vertex.color=vcol, edge.color=ecol)\n\n\n# Or we can highlight the immediate neighbors of a vertex, say WSJ.\n# The 'neighbors' function finds all nodes one step out from the focal actor.\n# To find the neighbors for multiple nodes, use 'adjacent_vertices()'.\n# To find node neighborhoods going more than one step out, use function 'ego()'\n# with parameter 'order' set to the number of steps out to go from the focal node(s).\n\nneigh.nodes <- neighbors(net, V(net)[media==\"Wall Street Journal\"], mode=\"out\")\n\n# Set colors to plot the neighbors:\nvcol[neigh.nodes] <- \"#ff9d00\"\nplot(net, vertex.color=vcol)\n \n\n# Another way to draw attention to a group of nodes:\nplot(net, mark.groups=c(1,4,5,8), mark.col=\"#C5E5E7\", mark.border=NA)\n# Mark multiple groups:\nplot(net, mark.groups=list(c(1,4,5,8), c(15:17)), \n          mark.col=c(\"#C5E5E7\",\"#ECD89A\"), mark.border=NA)\n\n\n\n# ------->> Interactive plotting with tkplot -------- \n\n# R and igraph offer interactive plotting capabilities\n# (mostly helpful for small networks)\n\ntkid <- tkplot(net) #tkid is the id of the tkplot\n\nl <- tkplot.getcoords(tkid) # grab the coordinates from tkplot\nplot(net, layout=l)\n\n\n\n# ------->> Other ways to represent a network -------- \n\n# One reminder that there are other ways to represent a network:\n\n# Heatmap of the network matrix:\nnetm <- as_adjacency_matrix(net, attr=\"weight\", sparse=F)\ncolnames(netm) <- V(net)$media\nrownames(netm) <- V(net)$media\n\npalf <- colorRampPalette(c(\"gold\", \"dark orange\")) \n\n# The Rowv & Colv parameters turn dendrograms on and off\nheatmap(netm[,17:1], Rowv = NA, Colv = NA, col = palf(20), \n        scale=\"none\", margins=c(10,10) )\n\n# Degree distribution\ndeg.dist <- degree_distribution(net, cumulative=T, mode=\"all\")\nplot( x=0:max(deg), y=1-deg.dist, pch=19, cex=1.4, col=\"orange\", \n      xlab=\"Degree\", ylab=\"Cumulative Frequency\")\n\n\n\n# ================ 4. Plotting two-mode networks ================\n\n\nhead(nodes2)\nhead(links2)\n\nnet2\nplot(net2)\n\n# This time we will make nodes look different based on their type.\n# Media outlets are blue squares, audience nodes are orange circles:\nV(net2)$color <- c(\"steel blue\", \"orange\")[V(net2)$type+1]\nV(net2)$shape <- c(\"square\", \"circle\")[V(net2)$type+1]\n\n# Media outlets will have name labels, audience members will not:\nV(net2)$label <- \"\"\nV(net2)$label[V(net2)$type==F] <- nodes2$media[V(net2)$type==F] \nV(net2)$label.cex=.6\nV(net2)$label.font=2\n\nplot(net2, vertex.label.color=\"white\", vertex.size=(2-V(net2)$type)*8) \n\n# igraph has a built-in bipartite layout, though it's not the most helpful:\nplot(net2, vertex.label=NA, vertex.size=7, layout=layout_as_bipartite) \n\n \n# Using text as nodes:\npar(mar=c(0,0,0,0))\nplot(net2, vertex.shape=\"none\", vertex.label=nodes2$media,\n     vertex.label.color=V(net2)$color, vertex.label.font=2, \n     vertex.label.cex=.95, edge.color=\"gray70\",  edge.width=2)\n\ndev.off()\n\n\n# Using images as nodes\n# You will need the 'png' package to do this:\n\n# install.packages(\"png\")\nlibrary(\"png\")\n \nimg.1 <- readPNG(\"./Data files/images/news.png\")\nimg.2 <- readPNG(\"./Data files/images/user.png\")\n\nV(net2)$raster <- list(img.1, img.2)[V(net2)$type+1]\n\npar(mar=c(3,3,3,3))\n\nplot(net2, vertex.shape=\"raster\", vertex.label=NA,\n     vertex.size=16, vertex.size2=16, edge.width=2)\n\n# By the way, you can also add any image you want to any plot.\n# For example, many network graphs could be improved by a photo\n# of a puppy carrying a basket full of kittens.\nimg.3 <- readPNG(\"./Data files/images/puppy.png\")\nrasterImage(img.3,  xleft=-1.7, xright=0, ybottom=-1.2, ytop=0)\n\n\n# The numbers after the image are coordinates for the plot.\n# The limits of your plotting area are given in par()$usr\n\ndev.off()\n\ndetach(\"package:png\") \n\n# We can also generate and plot bipartite projections for the two-mode network:\n# (co-memberships are easy to calculate by multiplying the network matrix by\n# its transposed matrix, or using igraph's bipartite.projection function)\n\nnet2.bp <- bipartite.projection(net2)\n\n# We can calculate the projections manually as well:\n#   as_incidence_matrix(net2)  %*% t(as_incidence_matrix(net2))\n# t(as_incidence_matrix(net2)) %*%   as_incidence_matrix(net2)\n\npar(mfrow=c(1,2))\n\nplot(net2.bp$proj1, vertex.label.color=\"black\", vertex.label.dist=1,\n     vertex.label=nodes2$media[!is.na(nodes2$media.type)])\n\nplot(net2.bp$proj2, vertex.label.color=\"black\", vertex.label.dist=1,\n     vertex.label=nodes2$media[ is.na(nodes2$media.type)])\n\ndev.off()\n\n# PSA: Remember to detach packages when you are done with them!\n# You may run into problems if you have igraph and Statnet packages loaded together.\ndetach(\"package:igraph\")\n\n\n\n# ================ 5. Plotting multiplex networks ================\n\n\n# In some cases, the networks we want to plot are multigraphs: \n# they can have multiple edges connecting the same two nodes. \n#\n# A related concept, multiplex networks, contain multiple types of ties\n# -- e.g. friendship, romantic, and work relationships between individuals. \n\n# In our example network, we also have two tie types: hyperlinks and mentions. \n\n# One thing we can do is plot each type of tie separately:\n\nlibrary(\"igraph\")\n\nE(net)$width <- 2\nplot(net, edge.color=c(\"dark red\", \"slategrey\")[(E(net)$type==\"hyperlink\")+1],\n      vertex.color=\"gray40\", layout=layout_in_circle, edge.curved=.3)\n\n# Another way to delete edges using the minus operator:  \nnet.m <- net - E(net)[E(net)$type==\"hyperlink\"]\nnet.h <- net - E(net)[E(net)$type==\"mention\"]\n\n# Plot the two links separately:\npar(mfrow=c(1,2))\n\nplot(net.h, vertex.color=\"orange\", main=\"Tie: Hyperlink\")\nplot(net.m, vertex.color=\"lightsteelblue2\", main=\"Tie: Mention\")\n\ndev.off()\n\n# Make sure the nodes stay in the same place in both plots:\npar(mfrow=c(1,2),mar=c(1,1,4,1))\n\nl <- layout_with_fr(net)\nplot(net.h, vertex.color=\"orange\", layout=l, main=\"Tie: Hyperlink\")\nplot(net.m, vertex.color=\"lightsteelblue2\", layout=l, main=\"Tie: Mention\")\n\ndev.off()\n\n# In our example network, we don't have node dyads connected by multiple\n# types of connections (we never have both a 'hyperlink' and a 'mention'\n# tie between the same two news outlets) -- however that could happen.\n\n# One challenge in visualizing multiplex networks is that multiple \n# edges between the same two nodes may get plotted on top of each \n# other in a way that makes them impossible to distinguish. \n\n# For example, let us generate a simple multiplex network with\n# two nodes and three ties between them:\n\nmultigtr <- graph( edges=c(1,2, 1,2, 1,2), n=2 )\n\nl <- layout_with_kk(multigtr)\n\n# Let's just plot the graph:\nplot(multigtr, vertex.color=\"lightsteelblue\", vertex.frame.color=\"white\",\n     vertex.size=40, vertex.shape=\"circle\", vertex.label=NA,\n     edge.color=c(\"gold\", \"tomato\", \"yellowgreen\"), edge.width=10,\n     edge.arrow.size=5, edge.curved=0.1, layout=l)\n\n# Because all edges in the graph have the same curvature, they are drawn\n# over each other so that we only see the last one. What we can do is \n# assign each edge a different curvature. One useful function in 'igraph'\n# called curve_multiple() can help us here. For a graph G, curve.multiple(G)\n# will generate a curvature for each edge that maximizes visibility.\n\nplot(multigtr, vertex.color=\"lightsteelblue\", vertex.frame.color=\"white\", \n     vertex.size=40, vertex.shape=\"circle\", vertex.label=NA,\n     edge.color=c(\"gold\", \"tomato\", \"yellowgreen\"), edge.width=10,\n     edge.arrow.size=5, edge.curved=curve_multiple(multigtr), layout=l)\n\n\ndev.off()\n\ndetach(\"package:igraph\")\n\n# ================ 6. Quick example using the 'network' package ================\n\n# Plotting with the 'network' package is very similar to that with 'igraph' -\n# although the notation is slightly different (a whole new set of parameter names!)\n# Here is a quick example using the (by now very familiar) media network.\n\n#Just in case we have forgotten this earlier:\ndev.off()\ndetach(\"package:igraph\")\n\n# Load our main package:\nlibrary(\"network\")\n\n# Wait, what did our data look like?\nhead(links)\nhead(nodes)\n\n# Convert the data into the network format used by the Statnet family.\n# As in igraph, we can generate a 'network' object from an edgelist, \n# an adjacency matrix, or an incidence matrix. \n?edgeset.constructors\n\n# Remember to set the ignore.eval to F for weighted networks.\nnet3 <- network(links, vertex.attr=nodes, matrix.type=\"edgelist\", \n                loops=F, multiple=F, ignore.eval = F)\nnet3\n\n# You can access the edges, vertices, and the network matrix using:\nnet3[,]\nnet3 %n% \"net.name\" <- \"Media Network\" #  network attribute\nnet3 %v% \"media\"    # Node attribute\nnet3 %e% \"type\"     # Node attribute\n \nnet3 %v% \"col\" <- c(\"gray70\", \"tomato\", \"gold\")[net3 %v% \"media.type\"]\n\n# plot the network:\nplot(net3, vertex.cex=(net3 %v% \"audience.size\")/7, vertex.col=\"col\")\n\n# For a full list of parameters that you can use in this plot, \n# check out ?plot.network.\n?plot.network\n\n# Note that - as in igraph - the plot returns the node position coordinates.\nl <- plot(net3, vertex.cex=(net3 %v% \"audience.size\")/7, vertex.col=\"col\")\nplot(net3, vertex.cex=(net3 %v% \"audience.size\")/7, vertex.col=\"col\", coord=l)\n\n\n# The network package also offers the option to edit a plot interactively,\n# by setting the parameter interactive=T\n\nplot(net3, vertex.cex=(net3 %v% \"audience.size\")/7, vertex.col=\"col\", interactive=T)\n\n\ndetach(\"package:network\")\n\n\n\n\n# ================ 7. Simple plot animations in R ================\n\n# If you have already installed \"ndtv\", you should also have\n# a package used by it called \"animation\".\n\n# install.packages(\"animation\")\nlibrary(\"animation\")\nlibrary(\"igraph\")\n\n# In order for this to work, you need not only the R package, but also\n# an additional software called ImageMagick from imagemagick.org \n# If you don't already have it, skip this part of the tutorial for now.\n\nani.options(\"convert\") # Check that the package knows where to find ImageMagick\nani.options(convert=\"C:/Progra~1/ImageMagick-7.0.6-Q16/convert.exe\") \n\n# You can use this technique to create various (not necessarily network-related)\n# animations in R by generating multiple plots and combining them in an animated GIF.\n\nl <- layout_with_fr(net)\n\nsaveGIF( {  col <- rep(\"grey40\", vcount(net))\n            plot(net, vertex.color=col, layout=l)\n            \n            step.1 <- V(net)[media==\"Wall Street Journal\"]\n            col[step.1] <- \"#ff5100\"\n            plot(net, vertex.color=col, layout=l)\n            \n            step.2 <- unlist(neighborhood(net, 1, step.1, mode=\"out\"))\n            col[setdiff(step.2, step.1)] <- \"#ff9d00\"\n            plot(net, vertex.color=col, layout=l) \n            \n            step.3 <- unlist(neighborhood(net, 2, step.1, mode=\"out\"))\n            col[setdiff(step.3, step.2)] <- \"#FFDD1F\"\n            plot(net, vertex.color=col, layout=l)  },\n          interval = .8, movie.name=\"network_animation.gif\" )\n\n detach(\"package:igraph\")\n detach(\"package:animation\")\n\n\n\n\n# ================ 8. Interactive JavaScript networks ================\n\n\n# There are a number of libraries like 'rcharts' and 'htmlwidgets' that can help you \n# export interactive web charts from R. We'll take a quick look at three packages that\n# can export networks from R to JavaScript: : 'visNetwork' and 'threejs', and 'networkD3'\n\n\n# ------->>  Interactive networks with visNetwork --------\n\n# install.packages(\"visNetwork\")\n\nlibrary(\"visNetwork\") \n\nhead(links)\nhead(nodes)\n\n# We can visualize the network right away - visNetwork() will accept \n# our node and link data frames (it needs node data with an 'id' column,\n# and edge data with 'from' and 'to' columns).\n\nvisNetwork(nodes, links)\n\n# We can set the height and width of the window visNetwork() takes \n# with parameters 'hight' and 'width', and the title with 'main'\n\nvisNetwork(nodes, links, height=\"600px\", width=\"100%\", main=\"Network!\")\n\n# Like 'igraph' did, 'visNetwork' allows us to set graphic properties \n# as node or edge attributes. We can add them as columns in our data.\n\n# Check out the available options with:\n?visNodes\n?visEdges\n \n\n# We'll start by changing the node parameters. \n\n# The options for  node shape include ellipse, circle, \n# database, box, text, image, circularImage, diamond, dot, \n# star, triangle, triangleDown, square, and icon.\n\nnodes$shape <- \"dot\"  \nnodes$shadow <- TRUE # Nodes will drop shadow\nnodes$title <- nodes$media # Text on click\nnodes$label <- nodes$type.label # Node label\nnodes$size <- nodes$audience.size # Node size\nnodes$borderWidth <- 2 # Node border width\n \n\n# We can set the color for several elements of the nodes:\n# \"background\" changes the node color, \"border\" changes the frame color;\n# \"highlight\" sets the color on click, \"hover\" sets the color on mouseover.\n\nnodes$color.background <- c(\"slategrey\", \"tomato\", \"gold\")[nodes$media.type]\nnodes$color.border <- \"black\"\nnodes$color.highlight.background <- \"orange\"\nnodes$color.highlight.border <- \"darkred\"\n\nvisNetwork(nodes, links)\n\n# Below we change some of the visual properties of the edges:\n\nlinks$width <- 1+links$weight/8 # line width\nlinks$color <- \"gray\"    # line color  \nlinks$arrows <- \"middle\" # arrows: 'from', 'to', or 'middle'\nlinks$smooth <- FALSE    # should the edges be curved?\nlinks$shadow <- FALSE    # edge shadow\n\nvisNetwork(nodes, links)\n  \n# Remove the arrows and set the edge width to 1:\nlinks$arrows <- \"\" \nlinks$width  <- 1\n \n\n# 'visNetwork' offers a number of other options, including\n# highlighting the neighbors of a selected node, or adding \n# a drop-down menu to select groups of nodes. The groups are\n# based on a column from our data - here the type label.\n\nvisNetwork(nodes, links) %>%\n  visOptions(highlightNearest = TRUE, \n             selectedBy = \"type.label\")\n  \n\n# For more information, check out:\n?visOptions # available options \n?visLayout  # available layouts\n?visGroups  # using node groups\n?visLegend  # adding a legend\n \ndetach(\"package:visNetwork\")\n\n\n\n# ------->> Interactive networks with threejs --------\n\n# Another package exporting networks from R to a js library is 'threejs'\n# The nice thing about it is that it can read igraph objects.\n\n# install.packages(\"threejs\")\n\n\n# If you get errors or warnings using this library and the latest R version,\n# try installing the development version of the 'htmlwidgets' package\n\n# devtools::install_github('ramnathv/htmlwidgets')\n\n\nlibrary(threejs)\nlibrary(htmlwidgets)\nlibrary(igraph)\n \n# The main network plotting function - graphjs() will take an igraph object\n# without protest, so we could simply run this:\n\ngraphjs(net)\n\n# However, the current properties of our network do not render very well here.\n# To remedy that, we can create a graphjs-friendly object and edit it:\n\nnet.js <- igraph2graphjs(net)\nnet.js    \n\n# As in igraph, here we can specify edge color, size, label, and label color\n# by simply adding or editing the corresponding columns in the data:\n\nnet.js$nodes[,2] <- NULL #delete duplicated label column\nnet.js$nodes$label <- net.js$nodes$media\nnet.js$nodes$size <- net.js$nodes$size/10\n\n# Now we can call the graphjs() function again with better result.\n# Some of the parameters that we can add include 'main' for the plot title;\n# 'curvature' for the edge curvature; 'bg' for background color; \n# 'showLabels' to set labels to visible (TRUE) or not (FALSE); \n# 'attraction' and 'repulsion' to set how much nodes attract and repulse\n# each other; 'opacity' for node transparency (0 to 1); 'stroke' to indicate\n# whether nodes should be framed in a black circle (TRUE) or not (FALSE), etc.\n# For the full list of parameters, check out ?graphjs\n\ngjs <- graphjs(net.js, main=\"Network!\", bg=\"gray10\", showLabels=F, stroke=F, \n               curvature=0.1, attraction=0.9, repulsion=0.8, opacity=0.9)\n\nprint(gjs)\nsaveWidget(gjs, file=\"Media-Network-gjs.html\")\nbrowseURL(\"Media-Network-gjs.html\")\n \n\n# Once we open the resulting visualization in the browser, we can use the mouse to\n# control it: scrollwheel to zoom in and out, the left mouse button to rotate \n# the network, and the right mouse button to pan. \n\n# Another example is the 'Les Miserables' network included with the package:\n\ndata(LeMis)\nlemis.net <- graphjs(LeMis, main=\"Les Miserables\", showLabels=T)\nprint(lemis.net)\nsaveWidget(lemis.net, file=\"LeMis-Network-gjs.html\")\nbrowseURL(\"LeMis-Network-gjs.html\")\n \n\ndetach(package: igraph)\ndetach(package: threejs)\ndetach(package: htmlwidgets)\n\n\n# ------->>  Interactive Networks with networkD3 --------\n\n# Another package using JavaScript to export networks: networkD3\n\n# install.packages(\"networkD3\")\n\nlibrary(networkD3) \n \n# d3ForceNetwork expects node IDs that are numeric and start from 0\n# so we have to transform our character node IDs:\n\nel <- data.frame(from=as.numeric(factor(links$from))-1, \n                 to=as.numeric(factor(links$to))-1 )\n\n# The nodes need to be in the same order as the \"source\" column in links:\nnl <- cbind(idn=factor(nodes$media, levels=nodes$media), nodes) \n\n# The `Group` parameter is used to color the nodes.\n# Nodesize is not (as you might think) the size of the node, but the\n# number of the column in the node data that should be used for sizing.\n# The `charge` parameter guides node repulsion (if negative) or \n# attraction (if positive).\n\nforceNetwork(Links = el, Nodes = nl, Source=\"from\", Target=\"to\",\n               NodeID = \"idn\", Group = \"type.label\",linkWidth = 1,\n               linkColour = \"#afafaf\", fontSize=12, zoom=T, legend=T,\n               Nodesize=6, opacity = 1, charge=-600, \n               width = 600, height = 600)\n                 \n\ndetach(package: networkD3)\n\n\n\n\n# ================ 9. Interactive and dynamic networks with ndtv-d3 ================\n\n\n\n# ------->> Interactive network plots --------\n\n\n# install.packages(\"ndtv\", dependencies=T)\n\nlibrary(\"ndtv\")\n\n# You should not need additional software to produce web animations with 'ndtv' (below).\n# If you want to save the animations as  video  files ( see ?saveVideo), you have to\n# install a video converter called FFmpeg (ffmpg.org). To find out how to get the right \n# installation for your OS, check out ?install.ffmpeg  To use all available layouts, \n# you need to have Java installed on your machine.\n\n\n# Remember net3, our original media network turned into a 'network' object:\nnet3 \n\n# Let's create an interactive (but not yet dynamic!) visualization of net3.\n# You will recognize a lot of the plotting parameters from 'network':\n# Two new parameters set the tooltips (the popup labels you see when you \n# click on network elements); note that those can take html format.\n# 'launchBrowser=T' will open file 'filename' in your default browser.\n\nrender.d3movie(net3, usearrows = F, displaylabels = F, bg=\"#111111\", \n               vertex.border=\"#ffffff\", vertex.col =  net3 %v% \"col\",\n               vertex.cex = (net3 %v% \"audience.size\")/8, \n               edge.lwd = (net3 %e% \"weight\")/3, edge.col = '#55555599',\n               vertex.tooltip = paste(\"<b>Name:</b>\", (net3 %v% 'media') , \"<br>\",\n                                    \"<b>Type:</b>\", (net3 %v% 'type.label')),\n               edge.tooltip = paste(\"<b>Edge type:</b>\", (net3 %e% 'type'), \"<br>\", \n                                  \"<b>Edge weight:</b>\", (net3 %e% \"weight\" ) ),\n               launchBrowser=T, filename=\"Media-Network.html\" )  \n\n    \n# If you are going to embed this in a markdown document, \n# you would also need to add output.mode='inline' above.\n\n\n# ------->> Network evolution animations -------- \n\n\n# In order to work with the network animations in 'ndtv', \n# we need to understand the  dynamic network format used by \n# Statnet packages, implemented in 'networkDynamic'. It can \n# represent discrete or continuous longitudinal network structures. \n\n# Let's look at one of the example datasets included in the\n# package, containing simulation data based on the network of\n# business connections among Renaissance Florentine families:\n\ndata(short.stergm.sim)\nshort.stergm.sim \nhead(as.data.frame(short.stergm.sim))\n\n# We can also use 'network.extract()' to get a network that \n# only contains elements active at a given point/time interval.\n\n# Plot the network ignoring time (all nodes & edges that were ever present):\nplot(short.stergm.sim)  \n\n# Plot the network at time 1 (at=1):\nplot( network.extract(short.stergm.sim, at=1) )\n\n# Plot nodes & edges active for the entire period (`rule=all`) from 1 to 5:\nplot( network.extract(short.stergm.sim, onset=1, terminus=5, rule=\"all\") )\n\n#Plot nodes & edges active at any point (`rule=any`) between 1 and 10:\nplot( network.extract(short.stergm.sim, onset=1, terminus=10, rule=\"any\") ) \n\n# Let's make a quick d3 animation from the example network:\nrender.d3movie(short.stergm.sim,displaylabels=TRUE) \n\n\n# Next, we will create and animate our own dynamic network.\n\n# Dynamic network object can be generated in a number of ways: from \n# a set of networks/matrices representing different time points, or from\n# data frames/matrices with node lists and edge lists indicating when each\n# is active, or when they switch state. See ?networkDynamic for more information.\n\nnet3\nplot(net3)\n\nvs <- data.frame(onset=0, terminus=50, vertex.id=1:17)\nes <- data.frame(onset=1:49, terminus=50, \n                 head=as.matrix(net3, matrix.type=\"edgelist\")[,1],\n                 tail=as.matrix(net3, matrix.type=\"edgelist\")[,2])\nhead(vs)\nhead(es)\n\nnet3.dyn <- networkDynamic(base.net=net3, edge.spells=es, vertex.spells=vs)\n\n\n# Plot the network (all elements present at any time point): \nplot(net3.dyn, vertex.cex=(net3 %v% \"audience.size\")/7, vertex.col=\"col\")\n\n\n# Plot static images showing network evolution:\n\n\ncompute.animation(net3.dyn, animation.mode = \"kamadakawai\",\n                  slice.par=list(start=0, end=49, interval=10, \n                         aggregate.dur=10, rule='any'))\n\n# Show time evolution through static images at different time points:\n filmstrip(net3.dyn, displaylabels=F, mfrow=c(2, 3),\n           slice.par=list(start=0, end=49, interval=10, \n                         aggregate.dur=10, rule='any'))\n \n# We can pre-compute the animation coordinates (otherwise they get calculated when \n# you generate the animation). Here 'animation.mode' is the layout algorithm - \n# one of \"kamadakawai\", \"MDSJ\", \"Graphviz\"and \"useAttribute\" (user-generated).\n\n# Here 'slice.par' is a list of parameters controlling how the network visualization \n# moves through time. The parameter 'interval' is the time step between layouts, \n# 'aggregate.dur' is the period shown in each layout, 'rule' is the rule for \n# displaying elements (e.g. 'any': active at any point during that period, \n# 'all': active during the entire period, etc.)\n \n\n# Let's make an actual animation: \n \ncompute.animation(net3.dyn, animation.mode = \"kamadakawai\",\n                  slice.par=list(start=0, end=50, interval=1, \n                         aggregate.dur=1, rule='any'))\n\n\nrender.d3movie(net3.dyn, usearrows = F, \n               displaylabels = F, label=net3 %v% \"media\",\n               bg=\"#ffffff\", vertex.border=\"#333333\",\n               vertex.cex = degree(net3)/2,  \n               vertex.col = net3.dyn %v% \"col\",\n               edge.lwd = (net3.dyn %e% \"weight\")/3, \n               edge.col = '#55555599',\n               vertex.tooltip = paste(\"<b>Name:</b>\", (net3.dyn %v% \"media\") , \"<br>\",\n                                    \"<b>Type:</b>\", (net3.dyn %v% \"type.label\")),\n               edge.tooltip = paste(\"<b>Edge type:</b>\", (net3.dyn %e% \"type\"), \"<br>\", \n                                  \"<b>Edge weight:</b>\", (net3.dyn %e% \"weight\" ) ),\n               launchBrowser=T, filename=\"Media-Network-Dynamic.html\",\n               render.par=list(tween.frames = 30, show.time = F),\n               plot.par=list(mar=c(0,0,0,0)) )\n\n\n# In addition to dynamic nodes and edges, 'ndtv' takes dynamic attributes.\n# We could have added those to the 'es' and 'vs' data frames above.\n# However, the plotting function can also evaluate parameters\n# and generate dynamic arguments on the fly. For example,\n# function(slice) { do some calculations with slice } will perform operations\n# on the current time slice network, letting us change parameters dynamically.\n\n# See the node size below:\n\ncompute.animation(net3.dyn, animation.mode = \"kamadakawai\",\n                  slice.par=list(start=0, end=50, interval=4, \n                         aggregate.dur=1, rule='any'))\n\n\nrender.d3movie(net3.dyn, usearrows = F, \n               displaylabels = F, label=net3 %v% \"media\",\n               bg=\"#000000\", vertex.border=\"#dddddd\",\n               vertex.cex = function(slice){ degree(slice)/2.5 },  \n               vertex.col = net3.dyn %v% \"col\",\n               edge.lwd = (net3.dyn %e% \"weight\")/3, \n               edge.col = '#55555599',\n               vertex.tooltip = paste(\"<b>Name:</b>\", (net3.dyn %v% \"media\") , \"<br>\",\n                                    \"<b>Type:</b>\", (net3.dyn %v% \"type.label\")),\n               edge.tooltip = paste(\"<b>Edge type:</b>\", (net3.dyn %e% \"type\"), \"<br>\", \n                                  \"<b>Edge weight:</b>\", (net3.dyn %e% \"weight\" ) ),\n               launchBrowser=T, filename=\"Media-Network-even-more-Dynamic.html\",\n               render.par=list(tween.frames = 25, show.time = F) )\n\n\n\n\n# ================ 10. Plotting networks on a geographic map ================\n\n\n# The example below plots a network on a map using base R and mapping libraries.\n\n# Note that for those familiar with it, the package 'ggplot2' may provide \n# a more flexible way of doing this. Things there work similarly to below,\n# but you would use borders() to plot the map and geom_path() for the edges.\n\n\nrm(list = ls()) # clear the workspace \n\n\n# In order to plot on a map, we'll need two additional packages.\n# If you do not already have them, install those now:\n# install.packages(\"maps\")\n# install.packages(\"geosphere\")\n\nlibrary(\"maps\")\nlibrary(\"geosphere\")\n\n# Package 'maps' has built-in maps it can plot for you. For example:\n# ('col' is map fill, 'border' is  border color, 'bg' is  background color)\npar(mfrow = c(2,2))\nmap(\"usa\", col=\"tomato\",  border=\"gray10\", fill=TRUE, bg=\"gray30\")\nmap(\"state\", col=\"orange\",  border=\"gray10\", fill=TRUE, bg=\"gray30\")\nmap(\"county\", col=\"palegreen\",  border=\"gray10\", fill=TRUE, bg=\"gray30\")\nmap(\"world\", col=\"skyblue\",  border=\"gray10\", fill=TRUE, bg=\"gray30\")\n\ndev.off()\n\n# The data we will use contains US airports and flights among them. \n# The airport file includes info about latitude and longitude.\n# If we did not have those, we could use 'geocode()' from 'ggmap'\n# to get latitude and longitude for an address.\n\nairports <- read.csv(\"./Data Files/Dataset3-Airlines-NODES.csv\", header=TRUE) \nflights <- read.csv(\"./Data Files/Dataset3-Airlines-EDGES.csv\", header=TRUE, as.is=TRUE)\n\nhead(flights)\nhead(airports)\n\n# Select only large airports: ones with more than 10 connections in the data.\ntab <- table(flights$Source)\nbig.id <- names(tab)[tab>10]\nairports <- airports[airports$ID %in% big.id,]\nflights  <- flights[flights$Source %in% big.id & \n                    flights$Target %in% big.id, ]\n\n\n# Plot a map of the united states:\nmap(\"state\", col=\"grey20\", fill=TRUE, bg=\"black\", lwd=0.1)\n\n# Add a point on the map for each airport:\npoints(x=airports$longitude, y=airports$latitude, pch=19, \n       cex=airports$Visits/80, col=\"orange\")\n\n# Generate edge colors: lighter color means higher flight volume.\ncol.1 <- adjustcolor(\"orange red\", alpha=0.4)\ncol.2 <- adjustcolor(\"orange\", alpha=0.4)\nedge.pal <- colorRampPalette(c(col.1, col.2), alpha = TRUE)\nedge.col <- edge.pal(100)\n\n# For each flight, we will generate the coordinates of an arc that connects\n# its star and end point, using gcIntermediate() from package 'geosphere'.\n# Then we will plot that arc over the map using lines().\nfor(i in 1:nrow(flights))  {\n    node1 <- airports[airports$ID == flights[i,]$Source,]\n    node2 <- airports[airports$ID == flights[i,]$Target,]\n    \n    arc <- gcIntermediate( c(node1[1,]$longitude, node1[1,]$latitude), \n                           c(node2[1,]$longitude, node2[1,]$latitude), \n                           n=1000, addStartEnd=TRUE )\n    edge.ind <- round(100*flights[i,]$Freq / max(flights$Freq))\n    \n    lines(arc, col=edge.col[edge.ind], lwd=edge.ind/30)\n}\n\n\n\n# ================ |-------------| ================\n \n\n\n\n",
    "created" : 1500571746856.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "61999069",
    "id" : "20BCAE05",
    "lastKnownWriteTime" : 1497473230,
    "last_content_update" : 1497473230,
    "path" : "~/Downloads/polnet2017/Polnet 2017 R Network Visualization Workshop.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}